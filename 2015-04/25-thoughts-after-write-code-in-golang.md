Go语言-笔记和开发感受
====================

### 类型嵌入

Go语言使用类型嵌入来模拟通常面向对象中得继承。

- 接口嵌入的只能是接口，不能事结构
- 结构可以嵌入结构和接口
- 可以直接嵌入也可以当做变量嵌入

#### 直接嵌入和当做变量嵌入

```go
type A struct {
  Name string
}

//直接嵌入
type B struct {
  *A
  Age int
}

//当做变量嵌入
type C struct {
  V *A
  Gender string
}
a := *A{"zjy"}
b := &B{a, 32}
c := &C{a, "male"}

//直接嵌入可以使用被嵌入类的字段
fmt.Println(b.Name == "zjy")

//当做变量嵌入需要使用qualifier
fmt.Println(c.V.Name == "zjy")
```
#### 接受对象

b.Name的接受对象(receiver)是B内部的A，而不是B。如果A有相关方法，那么相关方法的的接受对象是B累不的A结构体，而不是B，B没有这个方法，也不是这个方法的Receiver。

这样的组合(composition)很纯粹，就是将两个结构绑在一起，起了一个新的名字而已。

#### 名称冲突

组合的一个问题就是名称冲突，解决是规则很简单

- 外层的名称覆盖内层的名称。(outter name hide the more deeply nested name)
- 同一层有相同名称会出现 Ambiguous，如果你访问了这个重名字段编译时会报错。如果你根本不使用这个字段，压根就没有什么问题。
- 如果避免报错，访问重名的类型，你可以加上类型的qualifer，类似c.`V`.Name。

命名冲突的解决也是基于类型组合的，在本质上就两块内存，名字重了，你需要特别指明你想访问的时那一块内存。

### 大小写控制的访问范围

### 写Go代码给我带来的两点思考

### Go语言错误处理的优缺点

### Go语言不太适合的地方

